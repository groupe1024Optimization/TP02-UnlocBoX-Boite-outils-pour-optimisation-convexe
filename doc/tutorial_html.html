<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutoriel UNLocBoX - Compressed Sensing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        nav {
            background: #2d3748;
            padding: 15px 40px;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background 0.3s;
        }
        
        nav a:hover {
            background: #4a5568;
        }
        
        main {
            padding: 40px;
        }
        
        section {
            margin-bottom: 50px;
            scroll-margin-top: 80px;
        }
        
        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }
        
        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }
        
        .theory-box {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .equation {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
            border: 1px solid #e2e8f0;
            text-align: center;
            font-size: 1.1em;
            overflow-x: auto;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
        }
        
        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }
        
        .code-header {
            background: #1a202c;
            color: #63b3ed;
            padding: 10px 20px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            margin: 20px 0 0 0;
        }
        
        .code-block + .code-block {
            margin-top: -20px;
            border-radius: 0 0 8px 8px;
        }
        
        .highlight {
            background: #fef5e7;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .note {
            background: #fffbeb;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .warning {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .success {
            background: #f0fdf4;
            border-left: 4px solid #10b981;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        ul, ol {
            margin: 15px 0 15px 30px;
        }
        
        li {
            margin: 8px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #e2e8f0;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background: #f7fafc;
        }
        
        .btn {
            display: inline-block;
            padding: 12px 24px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
            margin: 10px 5px;
        }
        
        .btn:hover {
            background: #764ba2;
        }
        
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 30px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }
            
            nav ul {
                flex-direction: column;
            }
            
            main {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>OPTIMISATION DES ALGORITHMES</h1>
            <h1>Tutoriel UNLocBoX</h1>
            <p>Compressed Sensing avec Méthodes Proximales</p>
            <p style="font-size: 0.9em; margin-top: 10px;">Université de Yaoundé I - Département d'Informatique</p>
        </header>
        
        <nav>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#theorie">Théorie</a></li>
                <li><a href="#installation">Installation</a></li>
                <li><a href="#implementation">Implémentation</a></li>
                <li><a href="#resultats">Résultats</a></li>
            </ul>
        </nav>
        
        <main>
            <section id="introduction">
                <h2>Introduction au Compressed Sensing</h2>
                
                <div class="theory-box">
                    <h3>Qu'est-ce que le Compressed Sensing ?</h3>
                    <p>Le <strong>Compressed Sensing</strong> (ou échantillonnage compressé) est une technique révolutionnaire qui permet de reconstruire un signal à partir d'un nombre réduit de mesures, bien inférieur au théorème d'échantillonnage de Shannon-Nyquist.</p>
                    <p>Ce théorème classique stipule qu'il faut échantillonner un signal au moins au double de sa fréquence maximale pour le reconstruire parfaitement. En revanche, le Compressed Sensing exploite la sparsité d'un signal (c'est-à-dire qu'il contient peu de coefficients non nuls dans une certaine base, comme la transformée de Fourier ou la transformée en cosinus discret) pour réduire le nombre de mesures nécessaires.</p>
                    <p><strong>Principe fondamental :</strong> Si un signal est sparse (peu de coefficients non nuls) dans une certaine base, il peut être reconstruit à partir d'un nombre de mesures proportionnel à sa sparsité plutôt qu'à sa dimension.</p>
                </div>
                
                <h3>Applications Pratiques</h3>
                <div class="grid">
                    <div class="card">
                        <h4>Imagerie Médicale</h4>
                        <p>IRM accélérée : réduction du temps d'acquisition</p>
                    </div>
                    <div class="card">
                        <h4>Radar et Communications</h4>
                        <p>Détection de signaux avec peu de capteurs</p>
                    </div>
                    <div class="card">
                        <h4>Photographie Computationnelle</h4>
                        <p>Acquisition d'images à partir de peu de pixels</p>
                    </div>
                    <div class="card">
                        <h4>Traitement Audio</h4>
                        <p>Compression et reconstruction de signaux audio</p>
                    </div>
                </div>
            </section>
            
            <section id="theorie">
                <h2>Fondements Théoriques</h2>
                
                <h3>1. Le Problème Mathématique</h3>
                <div class="theory-box">
                    <p>Nous cherchons à reconstruire un signal <span class="highlight">x ∈ ℝⁿ</span> à partir de mesures incomplètes :</p>
                    <div class="equation">
                        <strong>y = Φx + n</strong>
                    </div>
                    <p>où :</p>
                    <ul>
                        <li><strong>y ∈ ℝᵐ</strong> : vecteur de mesures (m << n)</li>
                        <li><strong>Φ ∈ ℝᵐˣⁿ</strong> : matrice de mesure</li>
                        <li><strong>x ∈ ℝⁿ</strong> : signal à reconstruire</li>
                        <li><strong>n ∈ ℝᵐ</strong> : bruit de mesure</li>
                    </ul>
                </div>
                
                <h3>2. Formulation par Optimisation Convexe</h3>
                <p>Le problème de reconstruction devient :</p>
                
                <div class="equation">
                    <strong>min<sub>x</sub> ||x||₁ &nbsp;&nbsp; s.t. &nbsp;&nbsp; ||Φx - y||₂ ≤ ε</strong>
                </div>
                
                <div class="note">
                    <strong>Pourquoi la norme ℓ₁ ?</strong><br>
                    La norme ℓ₁ est une relaxation convexe de la norme ℓ₀ (nombre de coefficients non nuls) qui favorise la sparsité tout en restant calculable efficacement.
                </div>
                
                <h3>3. Formulation Alternative (Pénalisée)</h3>
                <div class="equation">
                    <strong>min<sub>x</sub> ½||Φx - y||₂² + λ||x||₁</strong>
                </div>
                <p>Cette formulation équivaut à la précédente via le paramètre de régularisation <span class="highlight">λ > 0</span>.</p>
                
                <h3>4. L'Opérateur Proximal de la Norme ℓ₁</h3>
                <div class="theory-box">
                    <p>L'opérateur proximal de la norme ℓ₁ est le <strong>seuillage doux</strong> (soft-thresholding) :</p>
                    <div class="equation">
                        prox<sub>γ||·||₁</sub>(x) = sign(x) ⊙ max(|x| - γ, 0)
                    </div>
                    <p>où ⊙ désigne le produit de Hadamard (élément par élément).</p>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th>Norme</th>
                            <th>Opérateur Proximal</th>
                            <th>Effet</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ℓ₁</td>
                            <td>Soft-thresholding</td>
                            <td>Sparsité</td>
                        </tr>
                        <tr>
                            <td>ℓ₂²</td>
                            <td>Rétrécissement</td>
                            <td>Régularisation douce</td>
                        </tr>
                        <tr>
                            <td>TV</td>
                            <td>Débruitage TV</td>
                            <td>Préservation des contours</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <section id="installation">
                <h2>Installation et Configuration</h2>
                
                <h3>Étape 1 : Télécharger UNLocBoX</h3>
                <div class="code-header">Commandes système</div>
                <div class="code-block">
                    <pre>% Option 1: Téléchargement depuis le site officiel
% https://epfl-lts2.github.io/unlocbox-html/

% Option 2: Clonage depuis GitHub
git clone https://github.com/epfl-lts2/unlocbox.git</pre>
                </div>
                
                <h3>Étape 2 : Initialisation dans MATLAB</h3>
                <div class="code-header">Script MATLAB : init_unlocbox_tutorial.m</div>
                <div class="code-block">
                    <pre>%% Initialisation de UNLocBoX
% Ajouter le chemin vers le dossier UNLocBoX
addpath('chemin/vers/unlocbox');

% Initialiser la toolbox
init_unlocbox;

% Vérifier l'installation
if exist('prox_l1', 'file')
    disp('UNLocBoX installé correctement !');
else
    error('Erreur d''installation de UNLocBoX');
end

% Définir le niveau de verbosité global
global GLOBAL_VERBOSE;
GLOBAL_VERBOSE = 1;</pre>
                </div>
                
                <div class="success">
                    <strong>Vérification de l'installation</strong><br>
                    Si vous voyez le message "UNLocBoX installé correctement !", vous êtes prêt à continuer !
                </div>
            </section>
            
            <section id="implementation">
                <h2>Implémentation Complète</h2>
                
                <h3>Exemple 1 : Compressed Sensing Basique</h3>
                
                <div class="code-header">compressed_sensing_basic.m</div>
                <div class="code-block">
                    <pre>%% COMPRESSED SENSING AVEC UNLOCBOX - Exemple Basique


clear all; close all; clc;

%% 1. INITIALISATION
init_unlocbox;
rng(42); % Pour la reproductibilité

%% 2. GÉNÉRATION DU SIGNAL SPARSE
N = 1024;      % Dimension du signal
K = 50;        % Nombre de composantes non nulles (sparsité)
M = 256;       % Nombre de mesures (M << N)

% Créer un signal sparse 
x_true = zeros(N, 1);
support = randperm(N, K);  % Positions des éléments non nuls
x_true(support) = randn(K, 1);  % Valeurs aléatoires

fprintf('Signal créé : N=%d, K=%d (sparsité=%.1f%%)\n', ...
        N, K, 100*K/N);

%% 3. MATRICE DE MESURE ALÉATOIRE
% Matrice gaussienne aléatoire normalisée
Phi = randn(M, N) / sqrt(M);

% Effectuer les mesures
y_clean = Phi * x_true;

% Ajouter du bruit
sigma_noise = 0.01;
noise = sigma_noise * randn(M, 1);
y = y_clean + noise;

epsilon = sigma_noise * sqrt(M);  % Paramètre de contrainte

fprintf('Mesures effectuées : M=%d (taux compression=%.1f%%)\n', ...
        M, 100*M/N);

%% 4. DÉFINITION DES FONCTIONS POUR UNLOCBOX

% Fonction 1 : Norme L1 (favorise la sparsité)
lambda = 0.1;
f1.eval = @(x) lambda * norm(x, 1);
f1.prox = @(x, T) prox_l1(x, lambda*T);

% Fonction 2 : Fidélité aux données (projection sur boule L2)
param_proj.epsilon = epsilon;
param_proj.A = @(x) Phi * x;
param_proj.At = @(x) Phi' * x;
param_proj.y = y;
param_proj.verbose = 0;

f2.eval = @(x) eps;  % Fonction indicatrice
f2.prox = @(x, T) proj_b2(x, T, param_proj);

%% 5. RÉSOLUTION AVEC DOUGLAS-RACHFORD

% Paramètres du solveur
param.verbose = 1;
param.maxit = 500;
param.tol = 1e-4;
param.gamma = 1.0;

% Point initial
x0 = zeros(N, 1);

% Résoudre le problème
fprintf('\n=== Résolution avec Douglas-Rachford ===\n');
tic;
[x_rec_DR, info_DR] = douglas_rachford(x0, f1, f2, param);
time_DR = toc;

%% 6. RÉSOLUTION AVEC FORWARD-BACKWARD (FISTA)

% Redéfinir f2 comme fonction différentiable
f2_fb.eval = @(x) 0.5 * norm(Phi*x - y)^2;
f2_fb.grad = @(x) Phi' * (Phi*x - y);
f2_fb.beta = norm(Phi)^2;

fprintf('\n=== Résolution avec Forward-Backward (FISTA) ===\n');
param.gamma = 1.9 / f2_fb.beta;  % Pas adaptatif
tic;
[x_rec_FB, info_FB] = forward_backward(x0, f1, f2_fb, param);
time_FB = toc;

%% 7. ÉVALUATION DES RÉSULTATS

% Erreur de reconstruction
error_DR = norm(x_rec_DR - x_true) / norm(x_true);
error_FB = norm(x_rec_FB - x_true) / norm(x_true);

% Sparsité des solutions
sparsity_DR = sum(abs(x_rec_DR) > 1e-3);
sparsity_FB = sum(abs(x_rec_FB) > 1e-3);

fprintf('\n=== RÉSULTATS ===\n');
fprintf('Douglas-Rachford:\n');
fprintf('  Erreur relative: %.4f\n', error_DR);
fprintf('  Sparsité: %d/%d\n', sparsity_DR, N);
fprintf('  Temps: %.3f s\n', time_DR);
fprintf('  Itérations: %d\n', info_DR.iter);

fprintf('\nForward-Backward:\n');
fprintf('  Erreur relative: %.4f\n', error_FB);
fprintf('  Sparsité: %d/%d\n', sparsity_FB, N);
fprintf('  Temps: %.3f s\n', time_FB);
fprintf('  Itérations: %d\n', info_FB.iter);

%% 8. VISUALISATION

figure('Position', [100, 100, 1200, 800]);

% Signal original
subplot(3,2,1);
stem(x_true, 'LineWidth', 1.5);
title('Signal Original (Sparse)');
xlabel('Index'); ylabel('Amplitude');
grid on;

% Mesures
subplot(3,2,2);
plot(y, 'LineWidth', 1.5);
title(sprintf('Mesures Bruitées (M=%d)', M));
xlabel('Index'); ylabel('Amplitude');
grid on;

% Reconstruction Douglas-Rachford
subplot(3,2,3);
stem(x_rec_DR, 'LineWidth', 1.5);
title(sprintf('Reconstruction DR (Erreur=%.4f)', error_DR));
xlabel('Index'); ylabel('Amplitude');
grid on;

% Reconstruction Forward-Backward
subplot(3,2,4);
stem(x_rec_FB, 'LineWidth', 1.5);
title(sprintf('Reconstruction FB (Erreur=%.4f)', error_FB));
xlabel('Index'); ylabel('Amplitude');
grid on;

% Convergence DR
subplot(3,2,5);
semilogy(info_DR.objective, 'LineWidth', 2);
title('Convergence Douglas-Rachford');
xlabel('Itération'); ylabel('Fonction Objectif (log)');
grid on;

% Convergence FB
subplot(3,2,6);
semilogy(info_FB.objective, 'LineWidth', 2);
title('Convergence Forward-Backward');
xlabel('Itération'); ylabel('Fonction Objectif (log)');
grid on;

sgtitle('Compressed Sensing avec UNLocBoX', ...
        'FontSize', 14, 'FontWeight', 'bold');

%% 9. COMPARAISON DES SUPPORTS

figure('Position', [150, 150, 1000, 400]);

subplot(1,3,1);
stem(support, ones(size(support)), 'r', 'LineWidth', 2);
xlim([1 N]); ylim([0 1.5]);
title('Support Original');
xlabel('Index'); ylabel('Présence');
grid on;

subplot(1,3,2);
support_DR = find(abs(x_rec_DR) > 0.01);
stem(support_DR, ones(size(support_DR)), 'b', 'LineWidth', 2);
xlim([1 N]); ylim([0 1.5]);
title('Support Reconstruit (DR)');
xlabel('Index'); ylabel('Présence');
grid on;

subplot(1,3,3);
support_FB = find(abs(x_rec_FB) > 0.01);
stem(support_FB, ones(size(support_FB)), 'g', 'LineWidth', 2);
xlim([1 N]); ylim([0 1.5]);
title('Support Reconstruit (FB)');
xlabel('Index'); ylabel('Présence');
grid on;

sgtitle('Comparaison des Supports', ...
        'FontSize', 14, 'FontWeight', 'bold');</pre>
                </div>
                
                <h3>Exemple 2 : Reconstruction d'Image avec Sparsité DCT</h3>
                
                <div class="code-header">compressed_sensing_image.m</div>
                <div class="code-block">
                    <pre>%% COMPRESSED SENSING POUR IMAGES - Sparsité dans DCT
% Université de Yaoundé I - Département d'Informatique

clear all; close all; clc;

%% 1. INITIALISATION
init_unlocbox;
rng(123);

%% 2. CHARGEMENT ET PRÉPARATION DE L'IMAGE

% Créer une image synthétique simple (ou charger une vraie image)
n = 64;  % Taille de l'image (n x n)
im_original = phantom(n);  % Image test
im_original = im_original / max(im_original(:));  % Normalisation

fprintf('Image chargée : %dx%d pixels\n', n, n);

%% 3. TRANSFORMATION DCT (base de sparsité)

% L'image est sparse dans la base DCT
DCT = @(x) dct2(x);
iDCT = @(x) idct2(x);

% Calculer les coefficients DCT
coeff_dct = DCT(im_original);

% Vérifier la sparsité
threshold = 0.1 * max(abs(coeff_dct(:)));
sparsity_ratio = sum(abs(coeff_dct(:)) > threshold) / numel(coeff_dct);
fprintf('Sparsité dans DCT : %.2f%%\n', 100*sparsity_ratio);

%% 4. ÉCHANTILLONNAGE ALÉATOIRE

% Taux d'échantillonnage
sampling_rate = 0.3;  % 30% des pixels
num_samples = round(sampling_rate * n^2);

% Masque d'échantillonnage aléatoire
mask = zeros(n, n);
idx_samples = randperm(n^2, num_samples);
mask(idx_samples) = 1;

% Mesures
y = mask .* im_original;
y_vec = y(mask == 1);  % Vecteur des mesures

fprintf('Échantillonnage : %.1f%% des pixels (%d/%d)\n', ...
        100*sampling_rate, num_samples, n^2);

%% 5. OPÉRATEURS LINÉAIRES

% Opérateur de mesure : A = Masque * iDCT
A_op = @(x) mask .* iDCT(reshape(x, n, n));
At_op = @(x) reshape(DCT(mask .* x), n^2, 1);

%% 6. DÉFINITION DES FONCTIONS

% Fonction 1 : Norme L1 dans le domaine DCT (sparsité)
lambda = 0.05;
f1.eval = @(x) lambda * norm(x, 1);
f1.prox = @(x, T) prox_l1(x, lambda*T);

% Fonction 2 : Fidélité aux données
param_l2.A = A_op;
param_l2.At = At_op;
param_l2.y = y;
param_l2.verbose = 0;
param_l2.tight = 0;
param_l2.nu = 1;

f2.prox = @(x, T) prox_l2(reshape(x, n, n), T, param_l2);
f2.eval = @(x) 0.5 * norm(A_op(x) - y, 'fro')^2;

% Version avec gradient pour Forward-Backward
f2_grad.eval = f2.eval;
f2_grad.grad = @(x) reshape(At_op(A_op(x) - y), n^2, 1);
f2_grad.beta = 1;  % Approximation

%% 7. RÉSOLUTION

% Point initial : interpolation simple
x0 = reshape(DCT(y), n^2, 1);

% Paramètres du solveur
param.verbose = 1;
param.maxit = 200;
param.tol = 1e-4;
param.gamma = 1.5;

% Douglas-Rachford
fprintf('\n=== Résolution avec Douglas-Rachford ===\n');
tic;
[x_rec_vec, info] = douglas_rachford(x0, f1, f2, param);
time_rec = toc;

% Reconstruction de l'image
x_rec_dct = reshape(x_rec_vec, n, n);
im_reconstructed = iDCT(x_rec_dct);

%% 8. ÉVALUATION

% PSNR (Peak Signal-to-Noise Ratio)
mse = mean((im_original(:) - im_reconstructed(:)).^2);
psnr_val = 10 * log10(1 / mse);

% Erreur relative
rel_error = norm(im_original(:) - im_reconstructed(:)) / ...
            norm(im_original(:));

fprintf('\n=== RÉSULTATS ===\n');
fprintf('PSNR : %.2f dB\n', psnr_val);
fprintf('Erreur relative : %.4f\n', rel_error);
fprintf('Temps de calcul : %.3f s\n', time_rec);
fprintf('Itérations : %d\n', info.iter);

%% 9. VISUALISATION

figure('Position', [100, 100, 1400, 500]);

% Image originale
subplot(1,4,1);
imagesc(im_original); colormap gray; axis image;
title('Image Originale');
colorbar;

% Mesures (pixels échantillonnés)
subplot(1,4,2);
imagesc(y); colormap gray; axis image;
title(sprintf('Mesures (%.0f%%)', 100*sampling_rate));
colorbar;

% Image reconstruite
subplot(1,4,3);
imagesc(im_reconstructed); colormap gray; axis image;
title(sprintf('Reconstruction (PSNR=%.1f dB)', psnr_val));
colorbar;

% Différence
subplot(1,4,4);
imagesc(abs(im_original - im_reconstructed)); colormap hot; axis image;
title('Erreur de Reconstruction');
colorbar;

sgtitle('Compressed Sensing pour Images avec UNLocBoX', ...
        'FontSize', 14, 'FontWeight', 'bold');

% Coefficients DCT
figure('Position', [150, 150, 1200, 400]);

subplot(1,3,1);
imagesc(log10(abs(coeff_dct) + 1e-10)); colormap jet; axis image;
title('Coefficients DCT Originaux (log)');
colorbar;

subplot(1,3,2);
imagesc(log10(abs(x_rec_dct) + 1e-10)); colormap jet; axis image;
title('Coefficients DCT Reconstruits (log)');
colorbar;

subplot(1,3,3);
semilogy(info.objective, 'LineWidth', 2);
title('Convergence');
xlabel('Itération');
ylabel('Fonction Objectif (log)');
grid on;

sgtitle('Analyse dans le Domaine DCT', ...
        'FontSize', 14, 'FontWeight', 'bold');</pre>
                </div>
            </section>
            
            <section id="resultats">
                <h2>Analyse des Résultats</h2>
                
                <h3>Performance des Algorithmes</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Algorithme</th>
                            <th>Complexité/itération</th>
                            <th>Vitesse de convergence</th>
                            <th>Usage recommandé</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Douglas-Rachford</strong></td>
                            <td>O(N)</td>
                            <td>Linéaire</td>
                            <td>Fonctions non-différentiables</td>
                        </tr>
                        <tr>
                            <td><strong>Forward-Backward (FISTA)</strong></td>
                            <td>O(N)</td>
                            <td>O(1/k²)</td>
                            <td>Une fonction différentiable</td>
                        </tr>
                        <tr>
                            <td><strong>ADMM</strong></td>
                            <td>O(N)</td>
                            <td>Linéaire</td>
                            <td>Contraintes linéaires</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>Facteurs Influençant la Reconstruction</h3>
                <div class="grid">
                    <div class="card">
                        <h4>Sparsité du Signal</h4>
                        <p>Plus le signal est sparse, meilleure est la reconstruction. Règle empirique : M ≥ 2K log(N/K)</p>
                    </div>
                    <div class="card">
                        <h4>Cohérence de la Matrice</h4>
                        <p>Les matrices aléatoires (Gaussienne, Bernoulli) garantissent une faible cohérence avec haute probabilité.</p>
                    </div>
                    <div class="card">
                        <h4>Niveau de Bruit</h4>
                        <p>Le paramètre ε ou λ doit être ajusté en fonction du niveau de bruit dans les mesures.</p>
                    </div>
                    <div class="card">
                        <h4>Paramètres de l'Algorithme</h4>
                        <p>Le pas γ et le nombre d'itérations influencent la qualité et le temps de calcul.</p>
                    </div>
                </div>
                
                <div class="note">
                    <strong>Conseil Pratique</strong><br>
                    Pour choisir le paramètre de régularisation λ, commencez avec λ = 0.1 * ||Φᵀy||∞ et ajustez par validation croisée.
                </div>
                
                <h3>Interprétation des Résultats</h3>
                <div class="theory-box">
                    <h4>Métriques de Qualité</h4>
                    <ul>
                        <li><strong>Erreur Relative :</strong> ||x_rec - x_true|| / ||x_true||</li>
                        <li><strong>PSNR (images) :</strong> 10 log₁₀(MAX² / MSE)</li>
                        <li><strong>Taux de Réussite du Support :</strong> |Support_rec ∩ Support_true| / K</li>
                        <li><strong>Sparsité Effective :</strong> Nombre de coefficients > seuil</li>
                    </ul>
                </div>
            </section>
            
        </main>
        </div>
    </body>
</html>